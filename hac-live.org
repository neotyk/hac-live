#+TITLE: http.async.client live
#+AUTHOR: Hubert Iwaniuk
#+EMAIL: hubert@happyhacking.nl

* Abstract
  [[https://github.com/neotyk/http.async.client][http.async.client]] is no fancy name, but it says it all, doesn't it?
  Primary goal is simplicity but still powerful.


* Setup
  For tests we will need some small server to work against.

  #+begin_src clojure :export code :tangle src/hac_live/server.clj
    (ns hac-live.server
      (:require [noir.server :as server]
                [noir.content.getting-started]
                [noir.response :as response])
      (:use [noir.core :only [defpartial defpage]]
            [hiccup.core :only [html]]
            [hiccup.page-helpers :only [include-css html5]]))
    
    (defpartial layout [& content]
                (html5
                  [:head
                   [:title "http.async.client live"]
                   (include-css "/css/reset.css")]
                  [:body
                   [:div#wrapper
                    content]]))
    
    (defpage "/welcome" []
      (layout [:p "Welcome to http.async.client live"]))
    
    (defpage "/json" []
      (response/json {:status 0 :msg "simple, right?"}))
    
    (defpage "/json-q" {cmd :command}
      (response/json {:status 0
                      :command cmd
                      :msg "now with query argument you passed"}))
    
    (server/load-views-ns 'hac-live.server)
    
    (defn -main [& m]
      (let [port (Integer. (get (System/getenv) "PORT" "8080"))]
        (server/start port {:mode :dev :ns 'hac-live.server})))
    
    ;;
  #+end_src


* ns

  #+begin_src clojure :export code :tangle src/hac_live/core.clj
    (ns hac-live.core
      (:require [http.async.client :as http]
                [http.async.client.request :as http-r]
                [cheshire.core :as json])
      (:use [clojure.pprint :only [pprint]]))
    
    ;;
  #+end_src


* Create client

  #+begin_src clojure :export code :tangle src/hac_live/core.clj
    ;; Create client
    (def c (http/create-client))
    
    ;;
  #+end_src


* Simple GET

  HTTP request over the wire:
  #+begin_example
    GET /welcome HTTP/1.1
    Host: localhost:8080
    Connection: keep-alive
    Accept: */*
    User-Agent: http.async.client/0.4.5
    
  #+end_example

  Issue simple GET request:
  #+begin_src clojure :export code :tangle src/hac_live/core.clj
    ;; GET HTTP resource
    (-> (http/GET c "http://localhost:8080/welcome")
        http/await
        pprint)
    
    ;;
  #+end_src


* Inspect response

  HTTP response over the wire:
  #+begin_example
    HTTP/1.1 200 OK
    Date: Wed, 09 May 2012 06:58:49 GMT
    Set-Cookie: ring-session=905d7c4f-5811-4c36-a33b-0e7c8b21d91d;Path=/
    Content-Type: application/json; charset=ISO-8859-1
    Content-Length: 35
    Server: Jetty(6.1.25)
    
    {"status":0,"msg":"simple, right?"}
  #+end_example

  #+begin_src clojure :export code :tangle src/hac_live/core.clj
    
    ;; Inspecting HTTP response
    (def response (http/GET c "http://localhost:8080/json"))

    ;; HTTP response on the wire:
    (-> response
        http/status
        pprint)

    (-> response
        http/headers
        pprint)

    (-> response
        http/cookies
        pprint)

    (-> response
        http/string
        pprint)
    
    ;;
  #+end_src


* Read json
  #+begin_src clojure :export code :tangle src/hac_live/core.clj
    
    ;; reading json
    (-> response
        http/string
        (json/parse-string true)
        pprint)
    
    ;;
  #+end_src


* Request options
  There is more to issuing HTTP request than just URL.
  [[http://github/neotyk/http.async.client/][h.a.c]] now supports supports query, headers, body, cookies, proxy,
  authentication, timeouts.

  For complete list of samples please refer to docs.

  #+begin_src clojure :export code :tangle src/hac_live/core.clj
    
    ;; Provide query parameters to request
    (let [resp (http/GET c "http://localhost:8080/json-q"
                         :query {:command "get things done"})]
      (-> resp
          http/string
          (json/parse-string true)
          pprint))
    
    ;;
  #+end_src


* Towards async
  All samples so far where synchronous, let's do some asynchrony.

** TODO this is wrong example
   #+begin_src clojure :export code :tangle src/hac_live/core.clj
     ;; Issue 20 request w/o waiting for each one
     (let [reqs (for [n (range 20)] (http/GET c "http://localhost:8080/json-q"
                                              :query {:command n}))]
       ;; Issue 20 requests w/o waiting for response
       (doall reqs)
       (doseq [r reqs]
         (-> r
             http/string
             (json/parse-string true)
             :command
             println)))
     
     ;;
   #+end_src


* Callbacks
  You can provide callback fns for following events:
  - status line received
  - headers received
  - body part received
  - response completed
  - error


** Sample callbacks 1
   Sample body part and response completed callback usage:

   #+begin_src clojure :export code :tangle src/hac_live/core.clj
     
     (http-r/execute-request c (http-r/prepare-request :get "http://localhost:8080/json")
                             :part (fn [resp part]
                                     (println :p part)
                                     [part :continue] ;; store part in (:body resp)
                                     )
                             :completed (fn [resp]
                                          (println :d @(:body resp))))
     
     ;;
   #+end_src


** Sample callback 2
   Store some arbitrary value in response body
   #+begin_src clojure :export code :tangle src/hac_live/core.clj
     (http-r/execute-request c (http-r/prepare-request :get "http://localhost:8080/json")
                             :part (fn [resp part]
                                     (println :p part)
                                     [:test :continue] ;; store arbitrary data in (:body resp)
                                     )
                             :completed (fn [resp]
                                          (println :d @(:body resp))))
     
     ;;
   #+end_src


** Sample callback 3
   Lets execute a bit more requests:
   #+begin_src clojure :export code :tangle src/hac_live/core.clj
     ;; a bit more requests executed
     (let [r (http-r/prepare-request :get "http://localhost:8080/json")]
       (dotimes [n 20]
         (http-r/execute-request c r
                                 :part (fn [_ _]
                                         [n :continue]) ;; just store n in body
                                 :completed (fn [resp]
                                              (println :d @(:body resp))))))
     
     ;;
   #+end_src


* Clean up
  #+begin_src clojure :export code :tangle src/hac_live/core.clj
    ;; Close client
    (http/close c)
  #+end_src
